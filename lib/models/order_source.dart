class OrderSource {
  final String id;
  final String name;
  final String iconPath; // Path to icon asset or url
  final OrderSourceType type;
  final double commissionRate; // Percentage (0-100)
  final bool requiresCommissionInput;
  final CommissionInputType commissionInputType; // before_fee or after_fee
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;

  OrderSource({
    required this.id,
    required this.name,
    required this.iconPath,
    required this.type,
    this.commissionRate = 0,
    this.requiresCommissionInput = false,
    this.commissionInputType = CommissionInputType.afterFee,
    this.isActive = true,
    required this.createdAt,
    required this.updatedAt,
  });

  // Calculate amount after fee from amount before fee
  double calculateAmountAfterFee(double amountBeforeFee) {
    if (commissionRate == 0) return amountBeforeFee;
    return amountBeforeFee * (1 - commissionRate / 100);
  }

  // Calculate amount before fee from amount after fee
  double calculateAmountBeforeFee(double amountAfterFee) {
    if (commissionRate == 0) return amountAfterFee;
    return amountAfterFee / (1 - commissionRate / 100);
  }

  // Calculate commission fee
  double calculateCommissionFee(double amount, {bool isBeforeFee = true}) {
    if (commissionRate == 0) return 0;

    if (isBeforeFee) {
      return amount * (commissionRate / 100);
    } else {
      // If amount is after fee, calculate what the before fee amount was
      final beforeFee = calculateAmountBeforeFee(amount);
      return beforeFee - amount;
    }
  }

  OrderSource copyWith({
    String? id,
    String? name,
    String? iconPath,
    OrderSourceType? type,
    double? commissionRate,
    bool? requiresCommissionInput,
    CommissionInputType? commissionInputType,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return OrderSource(
      id: id ?? this.id,
      name: name ?? this.name,
      iconPath: iconPath ?? this.iconPath,
      type: type ?? this.type,
      commissionRate: commissionRate ?? this.commissionRate,
      requiresCommissionInput: requiresCommissionInput ?? this.requiresCommissionInput,
      commissionInputType: commissionInputType ?? this.commissionInputType,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  Map<String, dynamic> toMap() {
    final map = {
      'name': name,
      'icon_path': iconPath,
      'type': type.value,
      'commission_rate': commissionRate,
      'requires_commission_input': requiresCommissionInput ? 1 : 0,
      'commission_input_type': commissionInputType.value,
      'is_active': isActive ? 1 : 0,
      'created_at': createdAt.millisecondsSinceEpoch,
      'updated_at': updatedAt.millisecondsSinceEpoch,
    };

    // Only include id if it's a valid integer (for updates)
    // Don't include id for new records (let database auto-generate)
    final parsedId = int.tryParse(id);
    if (parsedId != null && parsedId > 0) {
      map['id'] = parsedId;
    }

    return map;
  }

  factory OrderSource.fromMap(Map<String, dynamic> map) {
    return OrderSource(
      id: map['id'].toString(),
      name: map['name'] as String,
      iconPath: map['icon_path'] as String,
      type: OrderSourceType.fromString(map['type'] as String),
      commissionRate: (map['commission_rate'] as num?)?.toDouble() ?? 0,
      requiresCommissionInput: _parseBoolFromDynamic(map['requires_commission_input']),
      commissionInputType: CommissionInputType.fromString(
        map['commission_input_type'] as String? ?? 'after_fee',
      ),
      isActive: _parseBoolFromDynamic(map['is_active']),
      createdAt: _parseDateTimeFromDynamic(map['created_at']),
      updatedAt: _parseDateTimeFromDynamic(map['updated_at']),
    );
  }

  /// Helper method to parse boolean from various data types
  static bool _parseBoolFromDynamic(dynamic value) {
    if (value is bool) {
      return value;
    } else if (value is int) {
      return value == 1;
    } else if (value is String) {
      return value.toLowerCase() == 'true' || value == '1';
    }
    return false; // Default to false for null or unexpected types
  }

  /// Helper method to parse DateTime from various data types
  static DateTime _parseDateTimeFromDynamic(dynamic value) {
    if (value is int) {
      return DateTime.fromMillisecondsSinceEpoch(value);
    } else if (value is String) {
      return DateTime.parse(value);
    }
    return DateTime.now(); // Default fallback
  }

  // Default order sources
  static List<OrderSource> getDefaultSources() {
    final now = DateTime.now();
    return [
      OrderSource(
        id: '', // Empty ID - will be auto-generated by database
        name: 'On site',
        iconPath: 'onsite',
        type: OrderSourceType.onsite,
        commissionRate: 0,
        requiresCommissionInput: false,
        isActive: true,
        createdAt: now,
        updatedAt: now,
      ),
      OrderSource(
        id: '', // Empty ID - will be auto-generated by database
        name: 'Takeaway',
        iconPath: 'takeaway',
        type: OrderSourceType.takeaway,
        commissionRate: 0,
        requiresCommissionInput: false,
        isActive: true,
        createdAt: now,
        updatedAt: now,
      ),
      OrderSource(
        id: '', // Empty ID - will be auto-generated by database
        name: 'Shopee',
        iconPath: 'shopee',
        type: OrderSourceType.delivery,
        commissionRate: 29,
        requiresCommissionInput: true,
        commissionInputType: CommissionInputType.afterFee,
        isActive: true,
        createdAt: now,
        updatedAt: now,
      ),
      OrderSource(
        id: '', // Empty ID - will be auto-generated by database
        name: 'Grab food',
        iconPath: 'grabfood',
        type: OrderSourceType.delivery,
        commissionRate: 25,
        requiresCommissionInput: true,
        commissionInputType: CommissionInputType.beforeFee,
        isActive: true,
        createdAt: now,
        updatedAt: now,
      ),
    ];
  }
}

enum OrderSourceType {
  onsite('onsite'),
  takeaway('takeaway'),
  delivery('delivery');

  const OrderSourceType(this.value);
  final String value;

  static OrderSourceType fromString(String value) {
    return OrderSourceType.values.firstWhere(
      (type) => type.value == value.toLowerCase(),
      orElse: () => OrderSourceType.onsite,
    );
  }
}

enum CommissionInputType {
  beforeFee('before_fee'),
  afterFee('after_fee');

  const CommissionInputType(this.value);
  final String value;

  static CommissionInputType fromString(String value) {
    return CommissionInputType.values.firstWhere(
      (type) => type.value == value,
      orElse: () => CommissionInputType.afterFee,
    );
  }
}
