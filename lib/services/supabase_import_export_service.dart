import 'dart:convert';
import '../models/menu_item.dart';
import '../models/menu_options.dart';
import '../models/customer.dart' as customer_model;
import '../models/order.dart';
import '../models/inventory_models.dart';
import '../models/order_source.dart';
import 'supabase_service.dart';

/// Comprehensive import/export service for Supabase data
/// Supports multiple formats: JSON, CSV, Excel-compatible CSV
class SupabaseImportExportService extends SupabaseService {

  // ============= MENU DATA IMPORT/EXPORT =============

  /// Import menu items from JSON format
  Future<ImportResult> importMenuItemsFromJson(String jsonData) async {
    try {
      final data = json.decode(jsonData);
      final items = <MenuItem>[];
      final errors = <String>[];

      if (data is List) {
        for (int i = 0; i < data.length; i++) {
          try {
            final item = _parseMenuItemFromMap(data[i]);
            items.add(item);
          } catch (e) {
            errors.add('Row $i: $e');
          }
        }
      } else {
        throw Exception('JSON must contain an array of menu items');
      }

      // Import to Supabase
      final menuService = SupabaseMenuService();
      final imported = <String>[];

      for (final item in items) {
        try {
          await menuService.createMenuItem(item);
          imported.add(item.name);
        } catch (e) {
          errors.add('Failed to import "${item.name}": $e');
        }
      }

      return ImportResult(
        totalItems: data.length,
        importedItems: imported.length,
        errors: errors,
        importedNames: imported,
      );
    } catch (e) {
      return ImportResult(
        totalItems: 0,
        importedItems: 0,
        errors: ['JSON parsing error: $e'],
        importedNames: [],
      );
    }
  }

  /// Import menu items from simple CSV format (manual parsing)
  Future<ImportResult> importMenuItemsFromCsv(String csvData) async {
    try {
      final lines = csvData.split('\n').where((line) => line.trim().isNotEmpty).toList();
      final errors = <String>[];
      final imported = <String>[];

      if (lines.isEmpty) {
        throw Exception('CSV file is empty');
      }

      final menuService = SupabaseMenuService();

      // Skip header row, process data rows
      // Expected format: name,price,category,description,available
      for (int i = 1; i < lines.length; i++) {
        try {
          final fields = lines[i].split(',').map((f) => f.trim()).toList();
          if (fields.length < 5) {
            errors.add('Row $i: Insufficient data columns (need: name,price,category,description,available)');
            continue;
          }

          final item = MenuItem(
            id: '', // Will be generated by Supabase
            name: fields[0],
            price: double.tryParse(fields[1]) ?? 0.0,
            categoryName: fields[2],
            description: fields[3],
            availableStatus: _parseBoolFromString(fields[4]),
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          );

          await menuService.createMenuItem(item);
          imported.add(item.name);
        } catch (e) {
          errors.add('Row $i: $e');
        }
      }

      return ImportResult(
        totalItems: lines.length - 1,
        importedItems: imported.length,
        errors: errors,
        importedNames: imported,
      );
    } catch (e) {
      return ImportResult(
        totalItems: 0,
        importedItems: 0,
        errors: ['CSV parsing error: $e'],
        importedNames: [],
      );
    }
  }

  /// Export menu items to JSON format
  Future<String> exportMenuItemsToJson() async {
    try {
      final menuService = SupabaseMenuService();
      final items = await menuService.getMenuItems();

      final exportData = items.map((item) => {
        'name': item.name,
        'price': item.price,
        'category': item.categoryName,
        'description': item.description,
        'available': item.availableStatus,
        'created_at': item.createdAt.toIso8601String(),
        'updated_at': item.updatedAt.toIso8601String(),
      }).toList();

      return json.encode(exportData);
    } catch (e) {
      throw Exception('Failed to export menu items: $e');
    }
  }

  /// Export menu items to CSV format (manual generation)
  Future<String> exportMenuItemsToCsv() async {
    try {
      final menuService = SupabaseMenuService();
      final items = await menuService.getMenuItems();

      final buffer = StringBuffer();

      // Header
      buffer.writeln('name,price,category,description,available,created_at,updated_at');

      // Data rows
      for (final item in items) {
        final row = [
          _escapeCsvField(item.name),
          item.price.toString(),
          _escapeCsvField(item.categoryName),
          _escapeCsvField(item.description ?? ''),
          item.availableStatus.toString(),
          item.createdAt.toIso8601String(),
          item.updatedAt.toIso8601String(),
        ];
        buffer.writeln(row.join(','));
      }

      return buffer.toString();
    } catch (e) {
      throw Exception('Failed to export menu items: $e');
    }
  }

  // ============= CUSTOMER DATA IMPORT/EXPORT =============

  /// Export customers to JSON format
  Future<String> exportCustomersToJson() async {
    try {
      final customerService = SupabaseCustomerService();
      final customers = await customerService.getCustomers();

      final exportData = customers.map((customer) => {
        'name': customer.name,
        'phone': customer.phone,
        'email': customer.email,
        'address': customer.address,
        'created_at': customer.createdAt.toIso8601String(),
        'updated_at': customer.updatedAt.toIso8601String(),
      }).toList();

      return json.encode(exportData);
    } catch (e) {
      throw Exception('Failed to export customers: $e');
    }
  }

  /// Export customers to CSV format
  Future<String> exportCustomersToCsv() async {
    try {
      // Note: SupabaseCustomerService.getAllCustomers() method needs to be implemented
      throw UnimplementedError('Customer export functionality needs SupabaseCustomerService.getAllCustomers() method');
    } catch (e) {
      throw Exception('Failed to export customers: $e');
    }
  }

  // ============= INVENTORY DATA IMPORT/EXPORT =============

  /// Export ingredients to JSON format
  Future<String> exportInventoryToJson() async {
    try {
      final inventoryService = SupabaseInventoryService();
      final ingredients = await inventoryService.getIngredients();

      final exportData = ingredients.map((ingredient) => {
        'name': ingredient.name,
        'category': ingredient.category,
        'unit': ingredient.unit,
        'current_quantity': ingredient.currentQuantity,
        'minimum_threshold': ingredient.minimumThreshold,
        'cost_per_unit': ingredient.costPerUnit,
        'supplier': ingredient.supplier,
        'description': ingredient.description,
        'is_active': ingredient.isActive,
        'created_at': ingredient.createdAt.toIso8601String(),
        'updated_at': ingredient.updatedAt.toIso8601String(),
      }).toList();

      return json.encode(exportData);
    } catch (e) {
      throw Exception('Failed to export inventory: $e');
    }
  }

  // ============= ORDER DATA EXPORT =============

  /// Export orders to JSON format (for analytics and backup)
  Future<String> exportOrdersToJson({DateTime? startDate, DateTime? endDate}) async {
    try {
      final orderService = SupabaseOrderService();
      final orders = await orderService.getOrders(
        startDate: startDate,
        endDate: endDate,
      );

      final exportData = orders.map((order) => {
        'order_number': order.orderNumber,
        'customer_name': order.customer.name,
        'customer_phone': order.customer.phone,
        'subtotal': order.subtotal,
        'total': order.total,
        'status': order.status.toString(),
        'payment_status': order.paymentStatus.toString(),
        'payment_method': order.paymentMethod.toString(),
        'order_type': order.orderType.toString(),
        'platform': order.platform,
        'items': order.items.map((item) => {
          'menu_item_name': item.menuItemName,
          'quantity': item.quantity,
          'base_price': item.basePrice,
          'subtotal': item.subtotal,
          'selected_options': item.selectedOptions,
        }).toList(),
        'created_at': order.createdAt.toIso8601String(),
      }).toList();

      return json.encode(exportData);
    } catch (e) {
      throw Exception('Failed to export orders: $e');
    }
  }

  // ============= COMPLETE SYSTEM BACKUP =============

  /// Create a complete system backup in JSON format
  Future<Map<String, dynamic>> createCompleteBackup() async {
    try {
      final backup = <String, dynamic>{
        'backup_created_at': DateTime.now().toIso8601String(),
        'version': '1.0',
        'data': {},
      };

      // Export all data types
      print('ðŸ“¦ Creating complete Supabase backup...');

      print('ðŸ“‹ Backing up menu items...');
      backup['data']['menu_items'] = json.decode(await exportMenuItemsToJson());

      print('ðŸ‘¥ Backing up customers...');
      backup['data']['customers'] = json.decode(await exportCustomersToJson());

      print('ðŸ“¦ Backing up inventory...');
      backup['data']['inventory'] = json.decode(await exportInventoryToJson());

      print('ðŸ›’ Backing up recent orders...');
      final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));
      backup['data']['recent_orders'] = json.decode(await exportOrdersToJson(startDate: thirtyDaysAgo));

      print('âœ… Backup complete!');

      return backup;
    } catch (e) {
      throw Exception('Failed to create complete backup: $e');
    }
  }

  // ============= HELPER METHODS =============

  MenuItem _parseMenuItemFromMap(Map<String, dynamic> map) {
    return MenuItem(
      id: '', // Will be generated by Supabase
      name: map['name']?.toString() ?? '',
      price: (map['price'] as num?)?.toDouble() ?? 0.0,
      categoryName: map['category']?.toString() ?? 'General',
      description: map['description']?.toString() ?? '',
      availableStatus: _parseBoolFromString(map['available']?.toString() ?? 'true'),
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
  }

  bool _parseBoolFromString(String value) {
    final normalized = value.toLowerCase().trim();
    return normalized == 'true' || normalized == '1' || normalized == 'yes' || normalized == 'available';
  }

  /// Escape special characters in CSV fields
  String _escapeCsvField(String field) {
    if (field.contains(',') || field.contains('"') || field.contains('\n')) {
      return '"${field.replaceAll('"', '""')}"';
    }
    return field;
  }
}

/// Result of an import operation
class ImportResult {
  final int totalItems;
  final int importedItems;
  final List<String> errors;
  final List<String> importedNames;

  ImportResult({
    required this.totalItems,
    required this.importedItems,
    required this.errors,
    required this.importedNames,
  });

  bool get hasErrors => errors.isNotEmpty;
  bool get isSuccess => importedItems > 0;
  double get successRate => totalItems > 0 ? importedItems / totalItems : 0.0;

  String get summary {
    return 'Imported $importedItems of $totalItems items (${(successRate * 100).toStringAsFixed(1)}% success rate)';
  }
}

/// Export format options
enum ExportFormat { json, csv }

/// Import format options
enum ImportFormat { json, csv }